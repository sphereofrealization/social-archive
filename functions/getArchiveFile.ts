import { createClientFromRequest } from 'npm:@base44/sdk@0.8.6';
import JSZip from 'npm:jszip@3.10.1';

Deno.serve(async (req) => {
  try {
    const base44 = createClientFromRequest(req);
    const user = await base44.auth.me();
    
    if (!user) {
      return Response.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await req.json();
    const fileUrl = body.fileUrl;
    
    if (!fileUrl) {
      return Response.json({ error: 'Missing fileUrl parameter' }, { status: 400 });
    }

    console.log("üì¶ Downloading archive from:", fileUrl);
    
    const response = await fetch(fileUrl);
    
    if (!response.ok) {
      return Response.json({ error: `Failed to fetch file: ${response.status}` }, { status: 400 });
    }
    
    const blob = await response.blob();
    console.log("üì¶ Archive size:", blob.size, "bytes");

    const zip = await JSZip.loadAsync(blob);
    console.log("üì¶ ZIP loaded successfully");
    
    const data = {
      profile: { name: "", email: "" },
      posts: [],
      friends: [],
      messages: [],
      photos: [],
      photoFiles: {},
      videoFiles: {},
      comments: [],
      reels: [],
      videos: [],
      checkins: [],
      likes: [],
      events: [],
      reviews: [],
      groups: [],
      marketplace: [],
      allData: {}
    };

    // Helper to decode Facebook's encoded text
    const decodeFacebookText = (text) => {
      if (!text) return "";
      return text
        .replace(/\\u00([0-9a-fA-F]{2})/g, (match, hex) => String.fromCharCode(parseInt(hex, 16)))
        .replace(/&#x([0-9a-fA-F]+);/g, (match, hex) => String.fromCharCode(parseInt(hex, 16)))
        .replace(/&quot;/g, '"')
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&nbsp;/g, ' ')
        .trim();
    };

    // Helper to extract text from HTML - strips all tags
    const stripHtmlTags = (html) => {
      if (!html) return "";
      return html
        .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
        .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
        .replace(/<[^>]+>/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    };

    // Helper to extract all text content from specific HTML elements
    const extractFromElements = (html, selector) => {
      const results = [];
      const regex = new RegExp(`<${selector}[^>]*>(.*?)<\/${selector}>`, 'gis');
      let match;
      while ((match = regex.exec(html)) !== null) {
        const text = decodeFacebookText(stripHtmlTags(match[1]));
        if (text && text.length > 0) {
          results.push(text);
        }
      }
      return results;
    };

    // PHASE 1: Extract all media files (photos and videos)
    console.log("üì∏ Phase 1: Extracting photos and videos...");
    let photoCount = 0, videoCount = 0;

    for (const [path, file] of Object.entries(zip.files)) {
      if (file.dir) continue;

      // Extract photos
      if (path.match(/\.(jpg|jpeg|png|gif|webp|bmp)$/i) && !path.includes('icon')) {
        try {
          const imageData = await file.async("base64");
          const ext = path.split('.').pop().toLowerCase();
          const mimeType = {
            'jpg': 'image/jpeg', 'jpeg': 'image/jpeg',
            'png': 'image/png', 'gif': 'image/gif',
            'webp': 'image/webp', 'bmp': 'image/bmp'
          }[ext] || 'image/jpeg';

          data.photoFiles[path] = `data:${mimeType};base64,${imageData}`;
          data.photos.push({ path, filename: path.split('/').pop(), timestamp: "" });
          photoCount++;
        } catch (err) {
          console.error(`‚ùå Failed to extract photo ${path}:`, err.message);
        }
      }

      // Extract videos
      if (path.match(/\.(mp4|mov|avi|mkv|webm|m4v)$/i)) {
        try {
          const videoData = await file.async("base64");
          const ext = path.split('.').pop().toLowerCase();
          const mimeType = {
            'mp4': 'video/mp4', 'webm': 'video/webm',
            'mov': 'video/quicktime', 'avi': 'video/x-msvideo'
          }[ext] || 'video/mp4';

          data.videoFiles[path] = `data:${mimeType};base64,${videoData}`;
          data.videos.push({ path, filename: path.split('/').pop(), timestamp: "" });
          videoCount++;
        } catch (err) {
          console.error(`‚ùå Failed to extract video ${path}:`, err.message);
        }
      }
    }

    console.log(`‚úÖ Extracted ${photoCount} photos, ${videoCount} videos`);

    // PHASE 2: Parse ALL HTML and JSON files using Facebook's actual structure
    console.log("üìÑ Phase 2: Comprehensively scanning archive...");

    for (const [path, file] of Object.entries(zip.files)) {
      if (file.dir) continue;

      try {
        const content = await file.async("text");

        // Extract profile name
        if (!data.profile.name) {
          const nameMatch = content.match(/Generated by ([^<\n]+) on/i);
          if (nameMatch) {
            data.profile.name = decodeFacebookText(nameMatch[1].trim());
          }
        }

        // === POSTS (HTML) - Facebook uses <section> elements ===
        if (path.endsWith('.html') && (
          path.includes('your_posts') || 
          path.includes('posts/') ||
          path.includes('album/')
        )) {
          // Extract ALL sections
          const sections = content.matchAll(/<section[^>]*aria-labelledby="[^"]*">(.*?)<\/section>/gs);

          for (const section of sections) {
            const sectionHtml = section[1];

            // Get the h2 title (often describes the post type)
            const h2Match = sectionHtml.match(/<h2[^>]*>([^<]+)<\/h2>/);
            const title = h2Match ? decodeFacebookText(stripHtmlTags(h2Match[1])) : "";

            // Get the main content from div with class _2pin
            const contentMatch = sectionHtml.match(/<div class="_2pin"[^>]*>(.*?)<\/div>\s*<\/div>/s);
            const postContent = contentMatch ? decodeFacebookText(stripHtmlTags(contentMatch[1])) : "";

            // Get timestamp from footer
            const timestampMatch = sectionHtml.match(/<div class="_a72d">([^<]+)<\/div>/);
            const timestamp = timestampMatch ? decodeFacebookText(timestampMatch[1]) : "";

            // Try to find associated media
            const imgMatch = sectionHtml.match(/href="([^"]+\.(jpg|jpeg|png|gif))"/i);
            let photo_url = null;
            if (imgMatch) {
              const mediaPath = imgMatch[1];
              photo_url = data.photoFiles[mediaPath] || null;
            }

            // Combine title and content for the post text
            const postText = [title, postContent].filter(t => t && t.length > 0).join(' - ');

            if (postText.length >= 15) {
              data.posts.push({
                text: postText,
                timestamp,
                photo_url,
                likes_count: 0,
                comments_count: 0,
                comments: []
              });
            }
          }
        }

        // === COMMENTS (HTML) ===
        if (path.endsWith('.html') && path.match(/comments/i)) {
          const sections = content.matchAll(/<section[^>]*>(.*?)<\/section>/gs);

          for (const section of sections) {
            const sectionHtml = section[1];

            // Get h2 title (e.g., "Davis Matthews commented on...")
            const h2Match = sectionHtml.match(/<h2[^>]*>([^<]+)<\/h2>/);

            // Get actual comment text from _2pin div
            const contentMatch = sectionHtml.match(/<div class="_2pin"[^>]*><div>([^<]+)<\/div>/);
            const commentText = contentMatch ? decodeFacebookText(contentMatch[1]) : "";

            // Get timestamp
            const timestampMatch = sectionHtml.match(/<div class="_a72d">([^<]+)<\/div>/);
            const timestamp = timestampMatch ? decodeFacebookText(timestampMatch[1]) : "";

            if (commentText.length >= 10) {
              data.comments.push({ text: commentText, timestamp });
            }
          }
        }

        // === FRIENDS (HTML) ===
        if (path.endsWith('.html') && path.match(/friends/i)) {
          // Facebook friends are in section h2 elements
          const sections = content.matchAll(/<section[^>]*>(.*?)<\/section>/gs);

          for (const section of sections) {
            const sectionHtml = section[1];
            const h2Match = sectionHtml.match(/<h2[^>]*>([^<]+)<\/h2>/);
            if (h2Match) {
              const name = decodeFacebookText(h2Match[1].trim());
              if (name.length > 2 && name.length < 100 && 
                  !name.match(/Friends|Facebook|Privacy|Your friends/i) &&
                  !data.friends.find(f => f.name === name)) {

                // Try to get date
                const timestampMatch = sectionHtml.match(/<div class="_a72d">([^<]+)<\/div>/);
                const date_added = timestampMatch ? decodeFacebookText(timestampMatch[1]) : "";

                data.friends.push({ name, date_added });
              }
            }
          }
        }

        // === MESSAGES (JSON) ===
        if (path.endsWith('.json') && path.includes('message')) {
          try {
            const json = JSON.parse(content);
            if (json.messages && Array.isArray(json.messages)) {
              const convoName = decodeFacebookText(json.title || path.split('/').pop().replace('.json', '').replace(/_/g, ' '));
              const msgs = json.messages.map(m => ({
                sender: decodeFacebookText(m.sender_name || "Unknown"),
                text: decodeFacebookText(m.content || ""),
                timestamp: m.timestamp_ms ? new Date(m.timestamp_ms).toLocaleString() : "",
                timestamp_ms: m.timestamp_ms || 0
              })).filter(m => m.text);

              if (msgs.length > 0) {
                data.messages.push({
                  conversation_with: convoName,
                  messages: msgs,
                  lastMessageTimestamp: msgs[0]?.timestamp_ms || 0,
                  totalMessages: msgs.length
                });
              }
            }
          } catch (e) {}
        }

        // === POSTS & COMMENTS (JSON) ===
        if (path.endsWith('.json') && (path.includes('posts') || path.includes('comment'))) {
          try {
            const json = JSON.parse(content);

            // Posts
            const postsArray = Array.isArray(json) ? json : (json.posts || []);
            postsArray.forEach(post => {
              const postData = post.data?.[0] || post;
              const postText = decodeFacebookText(postData.post || postData.title || "");
              const timestamp = postData.timestamp ? new Date(postData.timestamp * 1000).toLocaleString() : "";

              if (postText && postText.length > 5) {
                let photo_url = null;
                if (post.attachments?.[0]?.data?.[0]?.media?.uri) {
                  const mediaUri = post.attachments[0].data[0].media.uri;
                  const mediaPath = path.split('/').slice(0, -1).join('/') + '/' + mediaUri;
                  photo_url = data.photoFiles[mediaPath] || null;
                }

                data.posts.push({
                  text: postText,
                  timestamp,
                  photo_url,
                  likes_count: 0,
                  comments_count: 0,
                  comments: []
                });
              }
            });

            // Comments
            const commentsArray = json.comments || [];
            commentsArray.forEach(comment => {
              const commentData = comment.data?.[0] || comment;
              const text = decodeFacebookText(commentData.comment?.comment || commentData.text || "");
              const timestamp = commentData.timestamp ? new Date(commentData.timestamp * 1000).toLocaleString() : "";

              if (text && text.length > 5) {
                data.comments.push({ text, timestamp });
              }
            });
          } catch (e) {}
        }

        // === FRIENDS (JSON) ===
        if (path.endsWith('.json') && path.includes('friends')) {
          try {
            const json = JSON.parse(content);
            const friendsList = json.friends_v2 || json.friends || [];

            friendsList.forEach(f => {
              const name = decodeFacebookText(f.name || f.title || "");
              if (name.length > 2 && !data.friends.find(fr => fr.name === name)) {
                data.friends.push({ 
                  name, 
                  date_added: f.timestamp ? new Date(f.timestamp * 1000).toLocaleDateString() : ""
                });
              }
            });
          } catch (e) {}
        }

      } catch (err) {
        console.error(`‚ùå ${path}: ${err.message}`);
      }
    }

    // Deduplicate and clean up
    data.friends = [...new Map(data.friends.map(f => [f.name.toLowerCase(), f])).values()];
    data.groups = [...new Map(data.groups.map(g => [g.name.toLowerCase(), g])).values()];
    data.messages.sort((a, b) => (b.lastMessageTimestamp || 0) - (a.lastMessageTimestamp || 0));

    console.log("\n‚úÖ EXTRACTION COMPLETE:");
    console.log(`  üë§ Profile: ${data.profile.name || 'Unknown'}`);
    console.log(`  üë• Friends: ${data.friends.length}`);
    console.log(`  üìù Posts: ${data.posts.length}`);
    console.log(`  üí¨ Messages: ${data.messages.length} conversations`);
    console.log(`  üì∏ Photos: ${Object.keys(data.photoFiles).length} (${data.photos.length} metadata)`);
    console.log(`  üé• Videos: ${Object.keys(data.videoFiles).length}`);
    console.log(`  üí≠ Comments: ${data.comments.length}`);
    console.log(`  üë• Groups: ${data.groups.length}`);

    return Response.json(data);
    
  } catch (error) {
    console.error("Error:", error);
    return Response.json({ error: error.message || 'Failed to extract archive' }, { status: 500 });
  }
});