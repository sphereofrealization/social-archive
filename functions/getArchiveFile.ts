import { createClientFromRequest } from 'npm:@base44/sdk@0.8.6';
import JSZip from 'npm:jszip@3.10.1';

Deno.serve(async (req) => {
  try {
    const base44 = createClientFromRequest(req);
    const user = await base44.auth.me();
    
    if (!user) {
      return Response.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await req.json();
    const fileUrl = body.fileUrl;
    
    if (!fileUrl) {
      return Response.json({ error: 'Missing fileUrl parameter' }, { status: 400 });
    }

    console.log("ðŸ“¦ Downloading archive...");
    const response = await fetch(fileUrl);
    if (!response.ok) {
      return Response.json({ error: `Failed to fetch: ${response.status}` }, { status: 400 });
    }
    
    const blob = await response.blob();
    const zip = await JSZip.loadAsync(blob);
    console.log("ðŸ“¦ ZIP loaded, extracting data...");
    
    const data = {
      profile: { name: "", email: "" },
      posts: [],
      friends: [],
      messages: [],
      photos: [],
      photoFiles: {},
      videoFiles: {},
      comments: [],
      groups: [],
      marketplace: [],
      events: [],
      reviews: []
    };

    const decode = (text) => {
      if (!text) return "";
      return text
        .replace(/&#039;/g, "'")
        .replace(/&quot;/g, '"')
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&nbsp;/g, ' ')
        .trim();
    };

    // Process all files
    for (const [path, file] of Object.entries(zip.files)) {
      if (file.dir) continue;
      
      try {
        const content = await file.async("text");
        
        // Get profile name
        if (!data.profile.name) {
          const nameMatch = content.match(/Generated by ([^<\n]+) on/i);
          if (nameMatch) data.profile.name = decode(nameMatch[1]);
        }
        
        // === ALL HTML FILES WITH SECTIONS ===
        if (path.endsWith('.html')) {
          const sections = content.matchAll(/<section[^>]*>(.*?)<\/section>/gs);
          
          for (const section of sections) {
            const html = section[1];
            
            // Get h2 title
            const h2 = html.match(/<h2[^>]*>([^<]+)<\/h2>/);
            const title = h2 ? decode(h2[1]) : "";
            
            // Get all _2pin divs (actual content)
            const contentDivs = html.matchAll(/<div class="_2pin"><div>([^<]+)<\/div>/g);
            const texts = [];
            for (const m of contentDivs) {
              texts.push(decode(m[1]));
            }
            
            // Get timestamp
            const time = html.match(/<div class="_a72d">([^<]+)<\/div>/);
            const timestamp = time ? decode(time[1]) : "";
            
            // Get media links
            const img = html.match(/href="([^"]+\.(jpg|jpeg|png|gif))"/i);
            const photoPath = img ? img[1] : null;
            
            const fullText = [title, ...texts].filter(t => t).join(' - ');
            
            // Categorize by file path
            if (path.includes('posts') || path.includes('album')) {
              if (fullText.length >= 10) {
                data.posts.push({ text: fullText, timestamp, photo_url: photoPath, likes_count: 0, comments_count: 0, comments: [] });
              }
            } else if (path.includes('comment')) {
              if (texts[0] && texts[0].length >= 10) {
                data.comments.push({ text: texts[0], timestamp });
              }
            } else if (path.includes('friends')) {
              if (title && title.length > 2 && title.length < 100 && !title.match(/Friends|Facebook|Your friends/i)) {
                if (!data.friends.find(f => f.name === title)) {
                  data.friends.push({ name: title, date_added: timestamp });
                }
              }
            } else if (path.includes('marketplace')) {
              if (fullText.length >= 10) {
                data.marketplace.push({ text: fullText, timestamp });
              }
            } else if (path.includes('events')) {
              if (fullText.length >= 10) {
                data.events.push({ text: fullText, timestamp });
              }
            } else if (path.includes('reviews')) {
              if (fullText.length >= 10) {
                data.reviews.push({ text: fullText, timestamp });
              }
            } else if (path.includes('groups')) {
              if (title && title.length > 3 && !title.match(/Groups|Facebook/i)) {
                if (!data.groups.find(g => g.name === title)) {
                  data.groups.push({ name: title });
                }
              }
            }
          }
        }
        
        // === JSON FILES ===
        if (path.endsWith('.json')) {
          try {
            const json = JSON.parse(content);
            
            // Messages
            if (json.messages && Array.isArray(json.messages)) {
              const msgs = json.messages.map(m => ({
                sender: decode(m.sender_name || ""),
                text: decode(m.content || ""),
                timestamp: m.timestamp_ms ? new Date(m.timestamp_ms).toLocaleString() : "",
                timestamp_ms: m.timestamp_ms || 0
              })).filter(m => m.text);
              
              if (msgs.length > 0) {
                data.messages.push({
                  conversation_with: decode(json.title || ""),
                  messages: msgs,
                  lastMessageTimestamp: msgs[0]?.timestamp_ms || 0,
                  totalMessages: msgs.length
                });
              }
            }
            
            // Friends
            const friendsList = json.friends_v2 || json.friends || [];
            friendsList.forEach(f => {
              const name = decode(f.name || "");
              if (name.length > 2 && !data.friends.find(fr => fr.name === name)) {
                data.friends.push({ name, date_added: "" });
              }
            });
            
            // Posts
            const posts = json.posts || (Array.isArray(json) ? json : []);
            posts.forEach(post => {
              const text = decode(post.data?.[0]?.post || post.post || "");
              if (text && text.length > 5) {
                data.posts.push({ text, timestamp: "", photo_url: null, likes_count: 0, comments_count: 0, comments: [] });
              }
            });
            
            // Comments
            const comments = json.comments || [];
            comments.forEach(c => {
              const text = decode(c.data?.[0]?.comment?.comment || c.text || "");
              if (text && text.length > 5) {
                data.comments.push({ text, timestamp: "" });
              }
            });
          } catch (e) {}
        }
        
      } catch (err) {}
    }

    // Get photo references (not base64 data - just paths)
    for (const [path] of Object.entries(zip.files)) {
      if (path.match(/\.(jpg|jpeg|png|gif)$/i) && !path.includes('icon')) {
        data.photos.push({ path, filename: path.split('/').pop() });
      }
    }

    data.friends = [...new Map(data.friends.map(f => [f.name.toLowerCase(), f])).values()];
    data.messages.sort((a, b) => b.lastMessageTimestamp - a.lastMessageTimestamp);

    console.log(`âœ… Profile: ${data.profile.name}, Posts: ${data.posts.length}, Comments: ${data.comments.length}, Friends: ${data.friends.length}, Messages: ${data.messages.length}`);

    return Response.json(data);
    
  } catch (error) {
    console.error("Error:", error);
    return Response.json({ error: error.message }, { status: 500 });
  }
});